// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  application: (where?: ApplicationWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  jobPosting: (where?: JobPostingWhereInput) => Promise<boolean>;
  note: (where?: NoteWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  application: (
    where: ApplicationWhereUniqueInput
  ) => ApplicationNullablePromise;
  applications: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Application>;
  applicationsConnection: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApplicationConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactNullablePromise;
  contacts: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contact>;
  contactsConnection: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactConnectionPromise;
  jobPosting: (where: JobPostingWhereUniqueInput) => JobPostingNullablePromise;
  jobPostings: (args?: {
    where?: JobPostingWhereInput;
    orderBy?: JobPostingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<JobPosting>;
  jobPostingsConnection: (args?: {
    where?: JobPostingWhereInput;
    orderBy?: JobPostingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JobPostingConnectionPromise;
  note: (where: NoteWhereUniqueInput) => NoteNullablePromise;
  notes: (args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Note>;
  notesConnection: (args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NoteConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApplication: (data: ApplicationCreateInput) => ApplicationPromise;
  updateApplication: (args: {
    data: ApplicationUpdateInput;
    where: ApplicationWhereUniqueInput;
  }) => ApplicationPromise;
  updateManyApplications: (args: {
    data: ApplicationUpdateManyMutationInput;
    where?: ApplicationWhereInput;
  }) => BatchPayloadPromise;
  upsertApplication: (args: {
    where: ApplicationWhereUniqueInput;
    create: ApplicationCreateInput;
    update: ApplicationUpdateInput;
  }) => ApplicationPromise;
  deleteApplication: (where: ApplicationWhereUniqueInput) => ApplicationPromise;
  deleteManyApplications: (
    where?: ApplicationWhereInput
  ) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (args: {
    data: ContactUpdateInput;
    where: ContactWhereUniqueInput;
  }) => ContactPromise;
  updateManyContacts: (args: {
    data: ContactUpdateManyMutationInput;
    where?: ContactWhereInput;
  }) => BatchPayloadPromise;
  upsertContact: (args: {
    where: ContactWhereUniqueInput;
    create: ContactCreateInput;
    update: ContactUpdateInput;
  }) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createJobPosting: (data: JobPostingCreateInput) => JobPostingPromise;
  updateJobPosting: (args: {
    data: JobPostingUpdateInput;
    where: JobPostingWhereUniqueInput;
  }) => JobPostingPromise;
  updateManyJobPostings: (args: {
    data: JobPostingUpdateManyMutationInput;
    where?: JobPostingWhereInput;
  }) => BatchPayloadPromise;
  upsertJobPosting: (args: {
    where: JobPostingWhereUniqueInput;
    create: JobPostingCreateInput;
    update: JobPostingUpdateInput;
  }) => JobPostingPromise;
  deleteJobPosting: (where: JobPostingWhereUniqueInput) => JobPostingPromise;
  deleteManyJobPostings: (where?: JobPostingWhereInput) => BatchPayloadPromise;
  createNote: (data: NoteCreateInput) => NotePromise;
  updateNote: (args: {
    data: NoteUpdateInput;
    where: NoteWhereUniqueInput;
  }) => NotePromise;
  updateManyNotes: (args: {
    data: NoteUpdateManyMutationInput;
    where?: NoteWhereInput;
  }) => BatchPayloadPromise;
  upsertNote: (args: {
    where: NoteWhereUniqueInput;
    create: NoteCreateInput;
    update: NoteUpdateInput;
  }) => NotePromise;
  deleteNote: (where: NoteWhereUniqueInput) => NotePromise;
  deleteManyNotes: (where?: NoteWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  application: (
    where?: ApplicationSubscriptionWhereInput
  ) => ApplicationSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  jobPosting: (
    where?: JobPostingSubscriptionWhereInput
  ) => JobPostingSubscriptionPayloadSubscription;
  note: (
    where?: NoteSubscriptionWhereInput
  ) => NoteSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type GenderOptions = "MALE" | "FEMALE" | "OTHER";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "jobTitle_ASC"
  | "jobTitle_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type JobPostingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "link_ASC"
  | "link_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "body_ASC"
  | "body_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ApplicationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "applied_ASC"
  | "applied_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "website_ASC"
  | "website_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "age_ASC"
  | "age_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ApplicationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ContactWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  jobTitle?: Maybe<String>;
  jobTitle_not?: Maybe<String>;
  jobTitle_in?: Maybe<String[] | String>;
  jobTitle_not_in?: Maybe<String[] | String>;
  jobTitle_lt?: Maybe<String>;
  jobTitle_lte?: Maybe<String>;
  jobTitle_gt?: Maybe<String>;
  jobTitle_gte?: Maybe<String>;
  jobTitle_contains?: Maybe<String>;
  jobTitle_not_contains?: Maybe<String>;
  jobTitle_starts_with?: Maybe<String>;
  jobTitle_not_starts_with?: Maybe<String>;
  jobTitle_ends_with?: Maybe<String>;
  jobTitle_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  notes_every?: Maybe<NoteWhereInput>;
  notes_some?: Maybe<NoteWhereInput>;
  notes_none?: Maybe<NoteWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  OR?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  NOT?: Maybe<ContactWhereInput[] | ContactWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  age?: Maybe<Int>;
  age_not?: Maybe<Int>;
  age_in?: Maybe<Int[] | Int>;
  age_not_in?: Maybe<Int[] | Int>;
  age_lt?: Maybe<Int>;
  age_lte?: Maybe<Int>;
  age_gt?: Maybe<Int>;
  age_gte?: Maybe<Int>;
  gender?: Maybe<GenderOptions>;
  gender_not?: Maybe<GenderOptions>;
  gender_in?: Maybe<GenderOptions[] | GenderOptions>;
  gender_not_in?: Maybe<GenderOptions[] | GenderOptions>;
  contacts_every?: Maybe<ContactWhereInput>;
  contacts_some?: Maybe<ContactWhereInput>;
  contacts_none?: Maybe<ContactWhereInput>;
  applications_every?: Maybe<ApplicationWhereInput>;
  applications_some?: Maybe<ApplicationWhereInput>;
  applications_none?: Maybe<ApplicationWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ApplicationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  applied?: Maybe<Boolean>;
  applied_not?: Maybe<Boolean>;
  user?: Maybe<UserWhereInput>;
  jobPosting?: Maybe<JobPostingWhereInput>;
  notes_every?: Maybe<NoteWhereInput>;
  notes_some?: Maybe<NoteWhereInput>;
  notes_none?: Maybe<NoteWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
  OR?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
  NOT?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
}

export interface JobPostingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  company?: Maybe<CompanyWhereInput>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<JobPostingWhereInput[] | JobPostingWhereInput>;
  OR?: Maybe<JobPostingWhereInput[] | JobPostingWhereInput>;
  NOT?: Maybe<JobPostingWhereInput[] | JobPostingWhereInput>;
}

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  employees_every?: Maybe<ContactWhereInput>;
  employees_some?: Maybe<ContactWhereInput>;
  employees_none?: Maybe<ContactWhereInput>;
  jobPostings_every?: Maybe<JobPostingWhereInput>;
  jobPostings_some?: Maybe<JobPostingWhereInput>;
  jobPostings_none?: Maybe<JobPostingWhereInput>;
  notes_every?: Maybe<NoteWhereInput>;
  notes_some?: Maybe<NoteWhereInput>;
  notes_none?: Maybe<NoteWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface NoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  application?: Maybe<ApplicationWhereInput>;
  contact?: Maybe<ContactWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NoteWhereInput[] | NoteWhereInput>;
  OR?: Maybe<NoteWhereInput[] | NoteWhereInput>;
  NOT?: Maybe<NoteWhereInput[] | NoteWhereInput>;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ContactWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type JobPostingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type NoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ApplicationCreateInput {
  id?: Maybe<ID_Input>;
  applied?: Maybe<Boolean>;
  user: UserCreateOneWithoutApplicationsInput;
  jobPosting: JobPostingCreateOneInput;
  notes?: Maybe<NoteCreateManyWithoutApplicationInput>;
}

export interface UserCreateOneWithoutApplicationsInput {
  create?: Maybe<UserCreateWithoutApplicationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutApplicationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  bio?: Maybe<String>;
  age?: Maybe<Int>;
  gender?: Maybe<GenderOptions>;
  contacts?: Maybe<ContactCreateManyWithoutUserInput>;
}

export interface ContactCreateManyWithoutUserInput {
  create?: Maybe<
    ContactCreateWithoutUserInput[] | ContactCreateWithoutUserInput
  >;
  connect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
}

export interface ContactCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  jobTitle?: Maybe<String>;
  company?: Maybe<CompanyCreateOneWithoutEmployeesInput>;
  notes?: Maybe<NoteCreateManyWithoutContactInput>;
}

export interface CompanyCreateOneWithoutEmployeesInput {
  create?: Maybe<CompanyCreateWithoutEmployeesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutEmployeesInput {
  id?: Maybe<ID_Input>;
  name: String;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  jobPostings?: Maybe<JobPostingCreateManyWithoutCompanyInput>;
  notes?: Maybe<NoteCreateManyWithoutCompanyInput>;
}

export interface JobPostingCreateManyWithoutCompanyInput {
  create?: Maybe<
    JobPostingCreateWithoutCompanyInput[] | JobPostingCreateWithoutCompanyInput
  >;
  connect?: Maybe<JobPostingWhereUniqueInput[] | JobPostingWhereUniqueInput>;
}

export interface JobPostingCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  title: String;
  link: String;
}

export interface NoteCreateManyWithoutCompanyInput {
  create?: Maybe<
    NoteCreateWithoutCompanyInput[] | NoteCreateWithoutCompanyInput
  >;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
}

export interface NoteCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  body: String;
  user: UserCreateOneInput;
  application?: Maybe<ApplicationCreateOneWithoutNotesInput>;
  contact?: Maybe<ContactCreateOneWithoutNotesInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  bio?: Maybe<String>;
  age?: Maybe<Int>;
  gender?: Maybe<GenderOptions>;
  contacts?: Maybe<ContactCreateManyWithoutUserInput>;
  applications?: Maybe<ApplicationCreateManyWithoutUserInput>;
}

export interface ApplicationCreateManyWithoutUserInput {
  create?: Maybe<
    ApplicationCreateWithoutUserInput[] | ApplicationCreateWithoutUserInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface ApplicationCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  applied?: Maybe<Boolean>;
  jobPosting: JobPostingCreateOneInput;
  notes?: Maybe<NoteCreateManyWithoutApplicationInput>;
}

export interface JobPostingCreateOneInput {
  create?: Maybe<JobPostingCreateInput>;
  connect?: Maybe<JobPostingWhereUniqueInput>;
}

export interface JobPostingCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  company: CompanyCreateOneWithoutJobPostingsInput;
  link: String;
}

export interface CompanyCreateOneWithoutJobPostingsInput {
  create?: Maybe<CompanyCreateWithoutJobPostingsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutJobPostingsInput {
  id?: Maybe<ID_Input>;
  name: String;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  employees?: Maybe<ContactCreateManyWithoutCompanyInput>;
  notes?: Maybe<NoteCreateManyWithoutCompanyInput>;
}

export interface ContactCreateManyWithoutCompanyInput {
  create?: Maybe<
    ContactCreateWithoutCompanyInput[] | ContactCreateWithoutCompanyInput
  >;
  connect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
}

export interface ContactCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  jobTitle?: Maybe<String>;
  user: UserCreateOneWithoutContactsInput;
  notes?: Maybe<NoteCreateManyWithoutContactInput>;
}

export interface UserCreateOneWithoutContactsInput {
  create?: Maybe<UserCreateWithoutContactsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutContactsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  bio?: Maybe<String>;
  age?: Maybe<Int>;
  gender?: Maybe<GenderOptions>;
  applications?: Maybe<ApplicationCreateManyWithoutUserInput>;
}

export interface NoteCreateManyWithoutContactInput {
  create?: Maybe<
    NoteCreateWithoutContactInput[] | NoteCreateWithoutContactInput
  >;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
}

export interface NoteCreateWithoutContactInput {
  id?: Maybe<ID_Input>;
  body: String;
  user: UserCreateOneInput;
  company?: Maybe<CompanyCreateOneWithoutNotesInput>;
  application?: Maybe<ApplicationCreateOneWithoutNotesInput>;
}

export interface CompanyCreateOneWithoutNotesInput {
  create?: Maybe<CompanyCreateWithoutNotesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutNotesInput {
  id?: Maybe<ID_Input>;
  name: String;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  employees?: Maybe<ContactCreateManyWithoutCompanyInput>;
  jobPostings?: Maybe<JobPostingCreateManyWithoutCompanyInput>;
}

export interface ApplicationCreateOneWithoutNotesInput {
  create?: Maybe<ApplicationCreateWithoutNotesInput>;
  connect?: Maybe<ApplicationWhereUniqueInput>;
}

export interface ApplicationCreateWithoutNotesInput {
  id?: Maybe<ID_Input>;
  applied?: Maybe<Boolean>;
  user: UserCreateOneWithoutApplicationsInput;
  jobPosting: JobPostingCreateOneInput;
}

export interface NoteCreateManyWithoutApplicationInput {
  create?: Maybe<
    NoteCreateWithoutApplicationInput[] | NoteCreateWithoutApplicationInput
  >;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
}

export interface NoteCreateWithoutApplicationInput {
  id?: Maybe<ID_Input>;
  body: String;
  user: UserCreateOneInput;
  company?: Maybe<CompanyCreateOneWithoutNotesInput>;
  contact?: Maybe<ContactCreateOneWithoutNotesInput>;
}

export interface ContactCreateOneWithoutNotesInput {
  create?: Maybe<ContactCreateWithoutNotesInput>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface ContactCreateWithoutNotesInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  jobTitle?: Maybe<String>;
  user: UserCreateOneWithoutContactsInput;
  company?: Maybe<CompanyCreateOneWithoutEmployeesInput>;
}

export interface ApplicationUpdateInput {
  applied?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneRequiredWithoutApplicationsInput>;
  jobPosting?: Maybe<JobPostingUpdateOneRequiredInput>;
  notes?: Maybe<NoteUpdateManyWithoutApplicationInput>;
}

export interface UserUpdateOneRequiredWithoutApplicationsInput {
  create?: Maybe<UserCreateWithoutApplicationsInput>;
  update?: Maybe<UserUpdateWithoutApplicationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutApplicationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutApplicationsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  bio?: Maybe<String>;
  age?: Maybe<Int>;
  gender?: Maybe<GenderOptions>;
  contacts?: Maybe<ContactUpdateManyWithoutUserInput>;
}

export interface ContactUpdateManyWithoutUserInput {
  create?: Maybe<
    ContactCreateWithoutUserInput[] | ContactCreateWithoutUserInput
  >;
  delete?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  connect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  set?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  disconnect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  update?: Maybe<
    | ContactUpdateWithWhereUniqueWithoutUserInput[]
    | ContactUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ContactUpsertWithWhereUniqueWithoutUserInput[]
    | ContactUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  updateMany?: Maybe<
    | ContactUpdateManyWithWhereNestedInput[]
    | ContactUpdateManyWithWhereNestedInput
  >;
}

export interface ContactUpdateWithWhereUniqueWithoutUserInput {
  where: ContactWhereUniqueInput;
  data: ContactUpdateWithoutUserDataInput;
}

export interface ContactUpdateWithoutUserDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  jobTitle?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneWithoutEmployeesInput>;
  notes?: Maybe<NoteUpdateManyWithoutContactInput>;
}

export interface CompanyUpdateOneWithoutEmployeesInput {
  create?: Maybe<CompanyCreateWithoutEmployeesInput>;
  update?: Maybe<CompanyUpdateWithoutEmployeesDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutEmployeesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutEmployeesDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  jobPostings?: Maybe<JobPostingUpdateManyWithoutCompanyInput>;
  notes?: Maybe<NoteUpdateManyWithoutCompanyInput>;
}

export interface JobPostingUpdateManyWithoutCompanyInput {
  create?: Maybe<
    JobPostingCreateWithoutCompanyInput[] | JobPostingCreateWithoutCompanyInput
  >;
  delete?: Maybe<JobPostingWhereUniqueInput[] | JobPostingWhereUniqueInput>;
  connect?: Maybe<JobPostingWhereUniqueInput[] | JobPostingWhereUniqueInput>;
  set?: Maybe<JobPostingWhereUniqueInput[] | JobPostingWhereUniqueInput>;
  disconnect?: Maybe<JobPostingWhereUniqueInput[] | JobPostingWhereUniqueInput>;
  update?: Maybe<
    | JobPostingUpdateWithWhereUniqueWithoutCompanyInput[]
    | JobPostingUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | JobPostingUpsertWithWhereUniqueWithoutCompanyInput[]
    | JobPostingUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<JobPostingScalarWhereInput[] | JobPostingScalarWhereInput>;
  updateMany?: Maybe<
    | JobPostingUpdateManyWithWhereNestedInput[]
    | JobPostingUpdateManyWithWhereNestedInput
  >;
}

export interface JobPostingUpdateWithWhereUniqueWithoutCompanyInput {
  where: JobPostingWhereUniqueInput;
  data: JobPostingUpdateWithoutCompanyDataInput;
}

export interface JobPostingUpdateWithoutCompanyDataInput {
  title?: Maybe<String>;
  link?: Maybe<String>;
}

export interface JobPostingUpsertWithWhereUniqueWithoutCompanyInput {
  where: JobPostingWhereUniqueInput;
  update: JobPostingUpdateWithoutCompanyDataInput;
  create: JobPostingCreateWithoutCompanyInput;
}

export interface JobPostingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<JobPostingScalarWhereInput[] | JobPostingScalarWhereInput>;
  OR?: Maybe<JobPostingScalarWhereInput[] | JobPostingScalarWhereInput>;
  NOT?: Maybe<JobPostingScalarWhereInput[] | JobPostingScalarWhereInput>;
}

export interface JobPostingUpdateManyWithWhereNestedInput {
  where: JobPostingScalarWhereInput;
  data: JobPostingUpdateManyDataInput;
}

export interface JobPostingUpdateManyDataInput {
  title?: Maybe<String>;
  link?: Maybe<String>;
}

export interface NoteUpdateManyWithoutCompanyInput {
  create?: Maybe<
    NoteCreateWithoutCompanyInput[] | NoteCreateWithoutCompanyInput
  >;
  delete?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  set?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  disconnect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  update?: Maybe<
    | NoteUpdateWithWhereUniqueWithoutCompanyInput[]
    | NoteUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | NoteUpsertWithWhereUniqueWithoutCompanyInput[]
    | NoteUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  updateMany?: Maybe<
    NoteUpdateManyWithWhereNestedInput[] | NoteUpdateManyWithWhereNestedInput
  >;
}

export interface NoteUpdateWithWhereUniqueWithoutCompanyInput {
  where: NoteWhereUniqueInput;
  data: NoteUpdateWithoutCompanyDataInput;
}

export interface NoteUpdateWithoutCompanyDataInput {
  body?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  application?: Maybe<ApplicationUpdateOneWithoutNotesInput>;
  contact?: Maybe<ContactUpdateOneWithoutNotesInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  bio?: Maybe<String>;
  age?: Maybe<Int>;
  gender?: Maybe<GenderOptions>;
  contacts?: Maybe<ContactUpdateManyWithoutUserInput>;
  applications?: Maybe<ApplicationUpdateManyWithoutUserInput>;
}

export interface ApplicationUpdateManyWithoutUserInput {
  create?: Maybe<
    ApplicationCreateWithoutUserInput[] | ApplicationCreateWithoutUserInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutUserInput[]
    | ApplicationUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutUserInput[]
    | ApplicationUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface ApplicationUpdateWithWhereUniqueWithoutUserInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutUserDataInput;
}

export interface ApplicationUpdateWithoutUserDataInput {
  applied?: Maybe<Boolean>;
  jobPosting?: Maybe<JobPostingUpdateOneRequiredInput>;
  notes?: Maybe<NoteUpdateManyWithoutApplicationInput>;
}

export interface JobPostingUpdateOneRequiredInput {
  create?: Maybe<JobPostingCreateInput>;
  update?: Maybe<JobPostingUpdateDataInput>;
  upsert?: Maybe<JobPostingUpsertNestedInput>;
  connect?: Maybe<JobPostingWhereUniqueInput>;
}

export interface JobPostingUpdateDataInput {
  title?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutJobPostingsInput>;
  link?: Maybe<String>;
}

export interface CompanyUpdateOneRequiredWithoutJobPostingsInput {
  create?: Maybe<CompanyCreateWithoutJobPostingsInput>;
  update?: Maybe<CompanyUpdateWithoutJobPostingsDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutJobPostingsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutJobPostingsDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  employees?: Maybe<ContactUpdateManyWithoutCompanyInput>;
  notes?: Maybe<NoteUpdateManyWithoutCompanyInput>;
}

export interface ContactUpdateManyWithoutCompanyInput {
  create?: Maybe<
    ContactCreateWithoutCompanyInput[] | ContactCreateWithoutCompanyInput
  >;
  delete?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  connect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  set?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  disconnect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  update?: Maybe<
    | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    | ContactUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    | ContactUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  updateMany?: Maybe<
    | ContactUpdateManyWithWhereNestedInput[]
    | ContactUpdateManyWithWhereNestedInput
  >;
}

export interface ContactUpdateWithWhereUniqueWithoutCompanyInput {
  where: ContactWhereUniqueInput;
  data: ContactUpdateWithoutCompanyDataInput;
}

export interface ContactUpdateWithoutCompanyDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  jobTitle?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutContactsInput>;
  notes?: Maybe<NoteUpdateManyWithoutContactInput>;
}

export interface UserUpdateOneRequiredWithoutContactsInput {
  create?: Maybe<UserCreateWithoutContactsInput>;
  update?: Maybe<UserUpdateWithoutContactsDataInput>;
  upsert?: Maybe<UserUpsertWithoutContactsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutContactsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  bio?: Maybe<String>;
  age?: Maybe<Int>;
  gender?: Maybe<GenderOptions>;
  applications?: Maybe<ApplicationUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutContactsInput {
  update: UserUpdateWithoutContactsDataInput;
  create: UserCreateWithoutContactsInput;
}

export interface NoteUpdateManyWithoutContactInput {
  create?: Maybe<
    NoteCreateWithoutContactInput[] | NoteCreateWithoutContactInput
  >;
  delete?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  set?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  disconnect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  update?: Maybe<
    | NoteUpdateWithWhereUniqueWithoutContactInput[]
    | NoteUpdateWithWhereUniqueWithoutContactInput
  >;
  upsert?: Maybe<
    | NoteUpsertWithWhereUniqueWithoutContactInput[]
    | NoteUpsertWithWhereUniqueWithoutContactInput
  >;
  deleteMany?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  updateMany?: Maybe<
    NoteUpdateManyWithWhereNestedInput[] | NoteUpdateManyWithWhereNestedInput
  >;
}

export interface NoteUpdateWithWhereUniqueWithoutContactInput {
  where: NoteWhereUniqueInput;
  data: NoteUpdateWithoutContactDataInput;
}

export interface NoteUpdateWithoutContactDataInput {
  body?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  company?: Maybe<CompanyUpdateOneWithoutNotesInput>;
  application?: Maybe<ApplicationUpdateOneWithoutNotesInput>;
}

export interface CompanyUpdateOneWithoutNotesInput {
  create?: Maybe<CompanyCreateWithoutNotesInput>;
  update?: Maybe<CompanyUpdateWithoutNotesDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutNotesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutNotesDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  employees?: Maybe<ContactUpdateManyWithoutCompanyInput>;
  jobPostings?: Maybe<JobPostingUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpsertWithoutNotesInput {
  update: CompanyUpdateWithoutNotesDataInput;
  create: CompanyCreateWithoutNotesInput;
}

export interface ApplicationUpdateOneWithoutNotesInput {
  create?: Maybe<ApplicationCreateWithoutNotesInput>;
  update?: Maybe<ApplicationUpdateWithoutNotesDataInput>;
  upsert?: Maybe<ApplicationUpsertWithoutNotesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ApplicationWhereUniqueInput>;
}

export interface ApplicationUpdateWithoutNotesDataInput {
  applied?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneRequiredWithoutApplicationsInput>;
  jobPosting?: Maybe<JobPostingUpdateOneRequiredInput>;
}

export interface ApplicationUpsertWithoutNotesInput {
  update: ApplicationUpdateWithoutNotesDataInput;
  create: ApplicationCreateWithoutNotesInput;
}

export interface NoteUpsertWithWhereUniqueWithoutContactInput {
  where: NoteWhereUniqueInput;
  update: NoteUpdateWithoutContactDataInput;
  create: NoteCreateWithoutContactInput;
}

export interface NoteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  OR?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  NOT?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
}

export interface NoteUpdateManyWithWhereNestedInput {
  where: NoteScalarWhereInput;
  data: NoteUpdateManyDataInput;
}

export interface NoteUpdateManyDataInput {
  body?: Maybe<String>;
}

export interface ContactUpsertWithWhereUniqueWithoutCompanyInput {
  where: ContactWhereUniqueInput;
  update: ContactUpdateWithoutCompanyDataInput;
  create: ContactCreateWithoutCompanyInput;
}

export interface ContactScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  jobTitle?: Maybe<String>;
  jobTitle_not?: Maybe<String>;
  jobTitle_in?: Maybe<String[] | String>;
  jobTitle_not_in?: Maybe<String[] | String>;
  jobTitle_lt?: Maybe<String>;
  jobTitle_lte?: Maybe<String>;
  jobTitle_gt?: Maybe<String>;
  jobTitle_gte?: Maybe<String>;
  jobTitle_contains?: Maybe<String>;
  jobTitle_not_contains?: Maybe<String>;
  jobTitle_starts_with?: Maybe<String>;
  jobTitle_not_starts_with?: Maybe<String>;
  jobTitle_ends_with?: Maybe<String>;
  jobTitle_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  OR?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  NOT?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
}

export interface ContactUpdateManyWithWhereNestedInput {
  where: ContactScalarWhereInput;
  data: ContactUpdateManyDataInput;
}

export interface ContactUpdateManyDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  jobTitle?: Maybe<String>;
}

export interface CompanyUpsertWithoutJobPostingsInput {
  update: CompanyUpdateWithoutJobPostingsDataInput;
  create: CompanyCreateWithoutJobPostingsInput;
}

export interface JobPostingUpsertNestedInput {
  update: JobPostingUpdateDataInput;
  create: JobPostingCreateInput;
}

export interface NoteUpdateManyWithoutApplicationInput {
  create?: Maybe<
    NoteCreateWithoutApplicationInput[] | NoteCreateWithoutApplicationInput
  >;
  delete?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  set?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  disconnect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  update?: Maybe<
    | NoteUpdateWithWhereUniqueWithoutApplicationInput[]
    | NoteUpdateWithWhereUniqueWithoutApplicationInput
  >;
  upsert?: Maybe<
    | NoteUpsertWithWhereUniqueWithoutApplicationInput[]
    | NoteUpsertWithWhereUniqueWithoutApplicationInput
  >;
  deleteMany?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  updateMany?: Maybe<
    NoteUpdateManyWithWhereNestedInput[] | NoteUpdateManyWithWhereNestedInput
  >;
}

export interface NoteUpdateWithWhereUniqueWithoutApplicationInput {
  where: NoteWhereUniqueInput;
  data: NoteUpdateWithoutApplicationDataInput;
}

export interface NoteUpdateWithoutApplicationDataInput {
  body?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  company?: Maybe<CompanyUpdateOneWithoutNotesInput>;
  contact?: Maybe<ContactUpdateOneWithoutNotesInput>;
}

export interface ContactUpdateOneWithoutNotesInput {
  create?: Maybe<ContactCreateWithoutNotesInput>;
  update?: Maybe<ContactUpdateWithoutNotesDataInput>;
  upsert?: Maybe<ContactUpsertWithoutNotesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface ContactUpdateWithoutNotesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  jobTitle?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutContactsInput>;
  company?: Maybe<CompanyUpdateOneWithoutEmployeesInput>;
}

export interface ContactUpsertWithoutNotesInput {
  update: ContactUpdateWithoutNotesDataInput;
  create: ContactCreateWithoutNotesInput;
}

export interface NoteUpsertWithWhereUniqueWithoutApplicationInput {
  where: NoteWhereUniqueInput;
  update: NoteUpdateWithoutApplicationDataInput;
  create: NoteCreateWithoutApplicationInput;
}

export interface ApplicationUpsertWithWhereUniqueWithoutUserInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutUserDataInput;
  create: ApplicationCreateWithoutUserInput;
}

export interface ApplicationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  applied?: Maybe<Boolean>;
  applied_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
  OR?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
  NOT?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
}

export interface ApplicationUpdateManyWithWhereNestedInput {
  where: ApplicationScalarWhereInput;
  data: ApplicationUpdateManyDataInput;
}

export interface ApplicationUpdateManyDataInput {
  applied?: Maybe<Boolean>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface NoteUpsertWithWhereUniqueWithoutCompanyInput {
  where: NoteWhereUniqueInput;
  update: NoteUpdateWithoutCompanyDataInput;
  create: NoteCreateWithoutCompanyInput;
}

export interface CompanyUpsertWithoutEmployeesInput {
  update: CompanyUpdateWithoutEmployeesDataInput;
  create: CompanyCreateWithoutEmployeesInput;
}

export interface ContactUpsertWithWhereUniqueWithoutUserInput {
  where: ContactWhereUniqueInput;
  update: ContactUpdateWithoutUserDataInput;
  create: ContactCreateWithoutUserInput;
}

export interface UserUpsertWithoutApplicationsInput {
  update: UserUpdateWithoutApplicationsDataInput;
  create: UserCreateWithoutApplicationsInput;
}

export interface ApplicationUpdateManyMutationInput {
  applied?: Maybe<Boolean>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  employees?: Maybe<ContactCreateManyWithoutCompanyInput>;
  jobPostings?: Maybe<JobPostingCreateManyWithoutCompanyInput>;
  notes?: Maybe<NoteCreateManyWithoutCompanyInput>;
}

export interface CompanyUpdateInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  employees?: Maybe<ContactUpdateManyWithoutCompanyInput>;
  jobPostings?: Maybe<JobPostingUpdateManyWithoutCompanyInput>;
  notes?: Maybe<NoteUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpdateManyMutationInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
}

export interface ContactCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  jobTitle?: Maybe<String>;
  user: UserCreateOneWithoutContactsInput;
  company?: Maybe<CompanyCreateOneWithoutEmployeesInput>;
  notes?: Maybe<NoteCreateManyWithoutContactInput>;
}

export interface ContactUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  jobTitle?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutContactsInput>;
  company?: Maybe<CompanyUpdateOneWithoutEmployeesInput>;
  notes?: Maybe<NoteUpdateManyWithoutContactInput>;
}

export interface ContactUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  jobTitle?: Maybe<String>;
}

export interface JobPostingUpdateInput {
  title?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutJobPostingsInput>;
  link?: Maybe<String>;
}

export interface JobPostingUpdateManyMutationInput {
  title?: Maybe<String>;
  link?: Maybe<String>;
}

export interface NoteCreateInput {
  id?: Maybe<ID_Input>;
  body: String;
  user: UserCreateOneInput;
  company?: Maybe<CompanyCreateOneWithoutNotesInput>;
  application?: Maybe<ApplicationCreateOneWithoutNotesInput>;
  contact?: Maybe<ContactCreateOneWithoutNotesInput>;
}

export interface NoteUpdateInput {
  body?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  company?: Maybe<CompanyUpdateOneWithoutNotesInput>;
  application?: Maybe<ApplicationUpdateOneWithoutNotesInput>;
  contact?: Maybe<ContactUpdateOneWithoutNotesInput>;
}

export interface NoteUpdateManyMutationInput {
  body?: Maybe<String>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  bio?: Maybe<String>;
  age?: Maybe<Int>;
  gender?: Maybe<GenderOptions>;
  contacts?: Maybe<ContactUpdateManyWithoutUserInput>;
  applications?: Maybe<ApplicationUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  bio?: Maybe<String>;
  age?: Maybe<Int>;
  gender?: Maybe<GenderOptions>;
}

export interface ApplicationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApplicationWhereInput>;
  AND?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactWhereInput>;
  AND?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  OR?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  NOT?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
}

export interface JobPostingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<JobPostingWhereInput>;
  AND?: Maybe<
    JobPostingSubscriptionWhereInput[] | JobPostingSubscriptionWhereInput
  >;
  OR?: Maybe<
    JobPostingSubscriptionWhereInput[] | JobPostingSubscriptionWhereInput
  >;
  NOT?: Maybe<
    JobPostingSubscriptionWhereInput[] | JobPostingSubscriptionWhereInput
  >;
}

export interface NoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NoteWhereInput>;
  AND?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
  OR?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
  NOT?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Application {
  id: ID_Output;
  applied: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ApplicationPromise extends Promise<Application>, Fragmentable {
  id: () => Promise<ID_Output>;
  applied: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
  jobPosting: <T = JobPostingPromise>() => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ApplicationSubscription
  extends Promise<AsyncIterator<Application>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  applied: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
  jobPosting: <T = JobPostingSubscription>() => T;
  notes: <T = Promise<AsyncIterator<NoteSubscription>>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ApplicationNullablePromise
  extends Promise<Application | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  applied: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
  jobPosting: <T = JobPostingPromise>() => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  bio?: String;
  age?: Int;
  gender?: GenderOptions;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  bio: () => Promise<String>;
  age: () => Promise<Int>;
  gender: () => Promise<GenderOptions>;
  contacts: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<GenderOptions>>;
  contacts: <T = Promise<AsyncIterator<ContactSubscription>>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  bio: () => Promise<String>;
  age: () => Promise<Int>;
  gender: () => Promise<GenderOptions>;
  contacts: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Contact {
  id: ID_Output;
  name: String;
  email?: String;
  phoneNumber?: String;
  jobTitle?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  jobTitle: () => Promise<String>;
  user: <T = UserPromise>() => T;
  company: <T = CompanyPromise>() => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  notes: <T = Promise<AsyncIterator<NoteSubscription>>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContactNullablePromise
  extends Promise<Contact | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  jobTitle: () => Promise<String>;
  user: <T = UserPromise>() => T;
  company: <T = CompanyPromise>() => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Company {
  id: ID_Output;
  name: String;
  address?: String;
  phoneNumber?: String;
  website?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  website: () => Promise<String>;
  employees: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  jobPostings: <T = FragmentableArray<JobPosting>>(args?: {
    where?: JobPostingWhereInput;
    orderBy?: JobPostingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  employees: <T = Promise<AsyncIterator<ContactSubscription>>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  jobPostings: <T = Promise<AsyncIterator<JobPostingSubscription>>>(args?: {
    where?: JobPostingWhereInput;
    orderBy?: JobPostingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notes: <T = Promise<AsyncIterator<NoteSubscription>>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  website: () => Promise<String>;
  employees: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  jobPostings: <T = FragmentableArray<JobPosting>>(args?: {
    where?: JobPostingWhereInput;
    orderBy?: JobPostingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface JobPosting {
  id: ID_Output;
  title: String;
  link: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface JobPostingPromise extends Promise<JobPosting>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  link: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface JobPostingSubscription
  extends Promise<AsyncIterator<JobPosting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
  link: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JobPostingNullablePromise
  extends Promise<JobPosting | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  link: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Note {
  id: ID_Output;
  body: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface NotePromise extends Promise<Note>, Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  user: <T = UserPromise>() => T;
  company: <T = CompanyPromise>() => T;
  application: <T = ApplicationPromise>() => T;
  contact: <T = ContactPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NoteSubscription
  extends Promise<AsyncIterator<Note>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  application: <T = ApplicationSubscription>() => T;
  contact: <T = ContactSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NoteNullablePromise
  extends Promise<Note | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  user: <T = UserPromise>() => T;
  company: <T = CompanyPromise>() => T;
  application: <T = ApplicationPromise>() => T;
  contact: <T = ContactPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ApplicationConnection {
  pageInfo: PageInfo;
  edges: ApplicationEdge[];
}

export interface ApplicationConnectionPromise
  extends Promise<ApplicationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplicationEdge>>() => T;
  aggregate: <T = AggregateApplicationPromise>() => T;
}

export interface ApplicationConnectionSubscription
  extends Promise<AsyncIterator<ApplicationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplicationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplicationSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationEdge {
  node: Application;
  cursor: String;
}

export interface ApplicationEdgePromise
  extends Promise<ApplicationEdge>,
    Fragmentable {
  node: <T = ApplicationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplicationEdgeSubscription
  extends Promise<AsyncIterator<ApplicationEdge>>,
    Fragmentable {
  node: <T = ApplicationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApplication {
  count: Int;
}

export interface AggregateApplicationPromise
  extends Promise<AggregateApplication>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplicationSubscription
  extends Promise<AsyncIterator<AggregateApplication>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface JobPostingConnection {
  pageInfo: PageInfo;
  edges: JobPostingEdge[];
}

export interface JobPostingConnectionPromise
  extends Promise<JobPostingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JobPostingEdge>>() => T;
  aggregate: <T = AggregateJobPostingPromise>() => T;
}

export interface JobPostingConnectionSubscription
  extends Promise<AsyncIterator<JobPostingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JobPostingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJobPostingSubscription>() => T;
}

export interface JobPostingEdge {
  node: JobPosting;
  cursor: String;
}

export interface JobPostingEdgePromise
  extends Promise<JobPostingEdge>,
    Fragmentable {
  node: <T = JobPostingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JobPostingEdgeSubscription
  extends Promise<AsyncIterator<JobPostingEdge>>,
    Fragmentable {
  node: <T = JobPostingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJobPosting {
  count: Int;
}

export interface AggregateJobPostingPromise
  extends Promise<AggregateJobPosting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJobPostingSubscription
  extends Promise<AsyncIterator<AggregateJobPosting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NoteConnection {
  pageInfo: PageInfo;
  edges: NoteEdge[];
}

export interface NoteConnectionPromise
  extends Promise<NoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NoteEdge>>() => T;
  aggregate: <T = AggregateNotePromise>() => T;
}

export interface NoteConnectionSubscription
  extends Promise<AsyncIterator<NoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNoteSubscription>() => T;
}

export interface NoteEdge {
  node: Note;
  cursor: String;
}

export interface NoteEdgePromise extends Promise<NoteEdge>, Fragmentable {
  node: <T = NotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NoteEdgeSubscription
  extends Promise<AsyncIterator<NoteEdge>>,
    Fragmentable {
  node: <T = NoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNote {
  count: Int;
}

export interface AggregateNotePromise
  extends Promise<AggregateNote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNoteSubscription
  extends Promise<AsyncIterator<AggregateNote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ApplicationSubscriptionPayload {
  mutation: MutationType;
  node: Application;
  updatedFields: String[];
  previousValues: ApplicationPreviousValues;
}

export interface ApplicationSubscriptionPayloadPromise
  extends Promise<ApplicationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplicationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplicationPreviousValuesPromise>() => T;
}

export interface ApplicationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplicationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplicationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplicationPreviousValuesSubscription>() => T;
}

export interface ApplicationPreviousValues {
  id: ID_Output;
  applied: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ApplicationPreviousValuesPromise
  extends Promise<ApplicationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  applied: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ApplicationPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplicationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  applied: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name: String;
  address?: String;
  phoneNumber?: String;
  website?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  website: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface ContactPreviousValues {
  id: ID_Output;
  name: String;
  email?: String;
  phoneNumber?: String;
  jobTitle?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  jobTitle: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JobPostingSubscriptionPayload {
  mutation: MutationType;
  node: JobPosting;
  updatedFields: String[];
  previousValues: JobPostingPreviousValues;
}

export interface JobPostingSubscriptionPayloadPromise
  extends Promise<JobPostingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JobPostingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JobPostingPreviousValuesPromise>() => T;
}

export interface JobPostingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JobPostingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JobPostingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JobPostingPreviousValuesSubscription>() => T;
}

export interface JobPostingPreviousValues {
  id: ID_Output;
  title: String;
  link: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface JobPostingPreviousValuesPromise
  extends Promise<JobPostingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  link: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface JobPostingPreviousValuesSubscription
  extends Promise<AsyncIterator<JobPostingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NoteSubscriptionPayload {
  mutation: MutationType;
  node: Note;
  updatedFields: String[];
  previousValues: NotePreviousValues;
}

export interface NoteSubscriptionPayloadPromise
  extends Promise<NoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotePreviousValuesPromise>() => T;
}

export interface NoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotePreviousValuesSubscription>() => T;
}

export interface NotePreviousValues {
  id: ID_Output;
  body: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface NotePreviousValuesPromise
  extends Promise<NotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NotePreviousValuesSubscription
  extends Promise<AsyncIterator<NotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  bio?: String;
  age?: Int;
  gender?: GenderOptions;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  bio: () => Promise<String>;
  age: () => Promise<Int>;
  gender: () => Promise<GenderOptions>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<GenderOptions>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "GenderOptions",
    embedded: false
  },
  {
    name: "Contact",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "JobPosting",
    embedded: false
  },
  {
    name: "Application",
    embedded: false
  },
  {
    name: "Note",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
